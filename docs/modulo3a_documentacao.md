# M√≥dulo 3-A: Implementando Opera√ß√µes de Cria√ß√£o (POST)
## üìù Criando Novos Filmes na API

### üìñ Objetivos do M√≥dulo
- Implementar endpoint POST para criar novos filmes
- Adicionar valida√ß√£o robusta de dados de entrada
- Reorganizar c√≥digo com handlers especializados
- Implementar middleware para logs e tratamento de erros
- Processar corretamente request body em formato JSON
- Melhorar a arquitetura da aplica√ß√£o

---

## üß† Conceitos Fundamentais

### O que s√£o M√©todos HTTP?
Os m√©todos HTTP definem a **inten√ß√£o** de uma requisi√ß√£o:

- **GET**: "Quero buscar dados" (n√£o modifica nada)
- **POST**: "Quero criar algo novo"
- **PUT**: "Quero atualizar completamente"
- **DELETE**: "Quero remover"
- **OPTIONS**: "Quero saber que opera√ß√µes posso fazer"

### Request Body vs URL Parameters
```
GET /filmes/123        ‚Üê ID na URL (par√¢metro)
POST /filmes           ‚Üê Dados no body JSON
{
  "titulo": "Novo Filme",
  "ano": 2024
}
```

### O que √© Middleware?
Middleware √© c√≥digo que executa **entre** o recebimento da requisi√ß√£o e o processamento final:

```
Request ‚Üí Middleware 1 ‚Üí Middleware 2 ‚Üí Handler ‚Üí Response
          (Logs)        (CORS)         (L√≥gica)
```

### Estruturas vs Handlers
- **Struct**: Agrupa dados relacionados
- **Methods em Struct**: Fun√ß√µes que "pertencem" √† struct
- **Handler**: Fun√ß√£o que processa requisi√ß√µes HTTP

---

## üèóÔ∏è Evolu√ß√£o da Arquitetura

### Estrutura Anterior (M√≥dulo 2):
```
api-filmes/
‚îú‚îÄ‚îÄ cmd/server/main.go     # Tudo misturado
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îî‚îÄ‚îÄ config/
```

### Nova Estrutura (M√≥dulo 3-A):
```
api-filmes/
‚îú‚îÄ‚îÄ cmd/
‚îÇ   ‚îî‚îÄ‚îÄ server/
‚îÇ       ‚îî‚îÄ‚îÄ main.go        # Apenas inicializa√ß√£o
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ handlers/          # ‚ú® L√≥gica HTTP separada
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ filme_handlers.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.go
‚îÇ   ‚îú‚îÄ‚îÄ models/            # Estruturas de dados
‚îÇ   ‚îú‚îÄ‚îÄ database/          # Opera√ß√µes de banco
‚îÇ   ‚îú‚îÄ‚îÄ config/            # Configura√ß√µes
‚îÇ   ‚îî‚îÄ‚îÄ validators/        # ‚ú® Valida√ß√£o de dados
‚îÇ       ‚îî‚îÄ‚îÄ filme_validator.go
```

### Benef√≠cios da Nova Estrutura:

**üéØ Separa√ß√£o de Responsabilidades:**
- `handlers/`: Apenas l√≥gica HTTP
- `validators/`: Apenas valida√ß√£o de dados
- `database/`: Apenas opera√ß√µes de banco
- `models/`: Apenas estruturas de dados

**üìà Escalabilidade:**
- F√°cil adicionar novos recursos
- C√≥digo organizado por fun√ß√£o
- Reutiliza√ß√£o de componentes

**üß™ Testabilidade:**
- Cada camada pode ser testada isoladamente
- Mocks mais f√°ceis de criar
- Testes unit√°rios espec√≠ficos

---

## üè≠ Sistema de Handlers Organizado

### Arquivo: `internal/handlers/filme_handlers.go`

### Struct FilmeHandler

```go
type FilmeHandler struct {
    bancoDados *database.BancoDados
}

func NovoFilmeHandler(bd *database.BancoDados) *FilmeHandler {
    return &FilmeHandler{
        bancoDados: bd,
    }
}
```

**Por que usar Struct para Handlers?**

**‚úÖ Vantagens:**
- **Encapsulamento**: Todos os m√©todos relacionados ficam juntos
- **Estado compartilhado**: Conex√£o de banco dispon√≠vel para todos os m√©todos
- **Organiza√ß√£o**: Agrupa funcionalidades relacionadas
- **Extensibilidade**: F√°cil adicionar novos campos (cache, logger, etc.)

**Compara√ß√£o com fun√ß√µes globais:**
```go
// ‚ùå Antes: fun√ß√£o global com vari√°vel global
var bancoDados *database.BancoDados

func listarFilmes(w http.ResponseWriter, r *http.Request) {
    // usa vari√°vel global
}

// ‚úÖ Agora: m√©todo em struct
func (fh *FilmeHandler) listarFilmes(w http.ResponseWriter, r *http.Request) {
    // usa fh.bancoDados
}
```

### M√©todo ManipularFilmes

```go
func (fh *FilmeHandler) ManipularFilmes(w http.ResponseWriter, r *http.Request) {
    configurarCabecalhos(w)
    
    switch r.Method {
    case "GET":
        fh.listarFilmes(w, r)
    case "POST":
        fh.criarFilme(w, r)          // ‚ú® NOVO
    case "OPTIONS":
        w.WriteHeader(http.StatusOK) // ‚ú® CORS Support
    default:
        enviarErro(w, "M√©todo n√£o permitido", http.StatusMethodNotAllowed)
    }
}
```

**Explica√ß√£o:**
1. **configurarCabecalhos()**: Define headers padr√£o (JSON, CORS)
2. **switch r.Method**: Roteia baseado no m√©todo HTTP
3. **OPTIONS**: Resposta para preflight requests do CORS
4. **default**: Qualquer m√©todo n√£o suportado retorna 405

### M√©todo criarFilme (Cora√ß√£o do M√≥dulo)

```go
func (fh *FilmeHandler) criarFilme(w http.ResponseWriter, r *http.Request) {
    fmt.Println("‚ûï Criando novo filme...")
    
    // 1. Verificar Content-Type
    if r.Header.Get("Content-Type") != "application/json" {
        enviarErro(w, "Content-Type deve ser application/json", http.StatusBadRequest)
        return
    }
```

**Por que verificar Content-Type?**
- **Seguran√ßa**: Evita processamento incorreto de dados
- **Clareza**: Cliente sabe exatamente que formato enviar
- **Robustez**: Evita erros de parsing

```go
    // 2. Decodificar JSON do body
    var novoFilme models.CriarFilme
    decoder := json.NewDecoder(r.Body)
    decoder.DisallowUnknownFields() // Rejeita campos n√£o reconhecidos
    
    if err := decoder.Decode(&novoFilme); err != nil {
        fmt.Printf("‚ùå Erro ao decodificar JSON: %v\n", err)
        enviarErro(w, "JSON inv√°lido", http.StatusBadRequest)
        return
    }
```

**json.NewDecoder vs json.Unmarshal:**
```go
// ‚úÖ NewDecoder - para http.Request.Body
decoder := json.NewDecoder(r.Body)
decoder.Decode(&struct)

// ‚úÖ Unmarshal - para []byte existente
var data []byte
json.Unmarshal(data, &struct)
```

**DisallowUnknownFields():**
```json
// ‚ùå Ser√° rejeitado
{
  "titulo": "Filme",
  "campo_inexistente": "valor"
}

// ‚úÖ Ser√° aceito
{
  "titulo": "Filme",
  "ano_lancamento": 2024
}
```

```go
    // 3. Validar dados
    if erros := validators.ValidarCriarFilme(&novoFilme); len(erros) > 0 {
        fmt.Printf("‚ùå Dados inv√°lidos: %v\n", erros)
        resposta := models.RespostaErro{
            Erro:     "Dados inv√°lidos",
            Codigo:   http.StatusBadRequest,
            Detalhes: strings.Join(erros, "; "),
        }
        enviarJSON(w, resposta, http.StatusBadRequest)
        return
    }
```

**Sistema de Valida√ß√£o:**
- Retorna **slice de erros** (m√∫ltiplos problemas)
- **strings.Join()** combina erros em uma string
- **Campo Detalhes** fornece informa√ß√µes espec√≠ficas

```go
    // 4. Salvar no banco
    filmeID, err := fh.bancoDados.CriarFilme(&novoFilme)
    if err != nil {
        fmt.Printf("‚ùå Erro ao salvar filme: %v\n", err)
        
        // Verificar se √© erro de duplica√ß√£o
        if strings.Contains(err.Error(), "duplicate") || strings.Contains(err.Error(), "unique") {
            enviarErro(w, "Filme com este t√≠tulo j√° existe", http.StatusConflict)
        } else {
            enviarErro(w, "Erro interno do servidor", http.StatusInternalServerError)
        }
        return
    }
```

**Tratamento Inteligente de Erros:**
- **409 Conflict**: Para viola√ß√µes de unicidade
- **500 Internal Server Error**: Para outros erros de banco
- **Log detalhado**: Para debugging
- **Mensagem amig√°vel**: Para o usu√°rio

```go
    // 5. Buscar filme criado para retornar completo
    filmeCriado, err := fh.bancoDados.BuscarFilmePorID(filmeID)
    if err != nil {
        // Fallback: retornar pelo menos o ID
        resposta := map[string]interface{}{
            "id":       filmeID,
            "mensagem": "Filme criado com sucesso",
        }
        enviarJSON(w, resposta, http.StatusCreated)
        return
    }
    
    fmt.Printf("‚úÖ Filme criado: %s (ID: %d)\n", filmeCriado.Titulo, filmeCriado.ID)
    enviarJSON(w, filmeCriado, http.StatusCreated)
```

**Por que buscar novamente?**
- **Dados completos**: Cliente recebe filme com timestamps
- **Consist√™ncia**: Mostra exatamente como foi salvo
- **Status 201**: Indica cria√ß√£o bem-sucedida
- **Fallback**: Se busca falhar, pelo menos retorna ID

---

## üö¶ Sistema de Middleware

### Arquivo: `internal/handlers/middleware.go`

### O que √© Middleware?

Middleware √© um padr√£o que permite executar c√≥digo **antes** e **depois** do handler principal:

```
Request ‚Üí [Middleware 1] ‚Üí [Middleware 2] ‚Üí [Handler] ‚Üí Response
            ‚Üì                ‚Üì              ‚Üì
          Logs            CORS           L√≥gica
          Autentica√ß√£o    Headers        Neg√≥cio
          Valida√ß√£o       Compress√£o     Database
```

### LogMiddleware

```go
func LogMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        inicio := time.Now()
        
        // Criar um ResponseWriter que captura o status code
        wrapperResposta := &responseWriter{
            ResponseWriter: w,
            statusCode:     http.StatusOK,
        }
        
        // Log da requisi√ß√£o
        fmt.Printf("üåê %s %s - IP: %s - User-Agent: %s\n",
            r.Method,
            r.URL.Path,
            obterIPReal(r),
            r.UserAgent(),
        )
        
        // Executar pr√≥ximo handler
        next.ServeHTTP(wrapperResposta, r)
        
        // Log da resposta
        duracao := time.Since(inicio)
        fmt.Printf("üìä %s %s - Status: %d - Dura√ß√£o: %v\n",
            r.Method,
            r.URL.Path,
            wrapperResposta.statusCode,
            duracao,
        )
    })
}
```

**Componentes do LogMiddleware:**

1. **Wrapper Function**: `func(next) func(w, r)`
2. **Timing**: `time.Now()` e `time.Since()`
3. **Response Wrapper**: Captura status code
4. **Informa√ß√µes √∫teis**: M√©todo, URL, IP, User-Agent, dura√ß√£o

### ResponseWriter Wrapper

```go
type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}
```

**Por que wrapper?**
- `http.ResponseWriter` n√£o exp√µe o status code escrito
- Precisamos "interceptar" a chamada `WriteHeader()`
- Salvar o c√≥digo para usar no log

### CORSMiddleware

```go
func CORSMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        w.Header().Set("Access-Control-Max-Age", "3600")
        
        // Se for preflight request, responder direto
        if r.Method == "OPTIONS" {
            w.WriteHeader(http.StatusOK)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}
```

**Headers CORS explicados:**
- **Allow-Origin**: Quais dom√≠nios podem fazer requests
- **Allow-Methods**: Que m√©todos HTTP s√£o permitidos
- **Allow-Headers**: Que headers o cliente pode enviar
- **Max-Age**: Quanto tempo o browser pode cachear as regras CORS

### RecuperacaoMiddleware

```go
func RecuperacaoMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                fmt.Printf("üö® PANIC recuperado: %v\n", err)
                
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusInternalServerError)
                
                resposta := `{"erro": "Erro interno do servidor", "codigo": 500}`
                w.Write([]byte(resposta))
            }
        }()
        
        next.ServeHTTP(w, r)
    })
}
```

**Por que Recovery Middleware?**
- **Graceful Degradation**: Aplica√ß√£o n√£o quebra totalmente
- **Logs de Error**: Captura panics para debugging
- **Resposta Consistente**: Sempre retorna JSON estruturado
- **Disponibilidade**: Mant√©m servidor rodando

---

## üìä Modelos de Dados Aprimorados

### Arquivo: `internal/models/filme.go` (Atualizado)

### Nova Struct: CriarFilme

```go
type CriarFilme struct {
    Titulo         string  `json:"titulo"`
    Descricao      string  `json:"descricao"`
    AnoLancamento  int     `json:"ano_lancamento"`
    DuracaoMinutos int     `json:"duracao_minutos"`
    Genero         string  `json:"genero"`
    Diretor        string  `json:"diretor"`
    Avaliacao      float64 `json:"avaliacao"`
}
```

**Por que struct separada para cria√ß√£o?**

**‚úÖ Vantagens:**
- **N√£o inclui campos auto-gerados**: ID, DataCriacao, DataAtualizacao
- **Valida√ß√£o espec√≠fica**: Regras diferentes para cria√ß√£o vs atualiza√ß√£o
- **Flexibilidade**: Pode ter campos opcionais diferentes
- **Clareza**: Intent expl√≠cito (criar vs buscar)

**Compara√ß√£o:**
```go
// ‚ùå Usando struct completa para cria√ß√£o
type Filme struct {
    ID              int       // Cliente n√£o deve enviar
    DataCriacao     time.Time // Servidor controla
    DataAtualizacao time.Time // Servidor controla
    // ... outros campos
}

// ‚úÖ Struct espec√≠fica para cria√ß√£o
type CriarFilme struct {
    // Apenas campos que cliente deve fornecer
}
```

### RespostaErro Aprimorada

```go
type RespostaErro struct {
    Erro     string `json:"erro"`
    Codigo   int    `json:"codigo"`
    Detalhes string `json:"detalhes,omitempty"`
}
```

**Campo Detalhes:**
- **omitempty**: S√≥ aparece se tiver conte√∫do
- **Uso**: Erros de valida√ß√£o com m√∫ltiplos problemas
- **Exemplo**: "t√≠tulo √© obrigat√≥rio; ano deve ser maior que 1888"

---

## üîç Sistema de Valida√ß√£o Robusto

### Arquivo: `internal/validators/filme_validator.go`

### Fun√ß√£o ValidarCriarFilme

```go
func ValidarCriarFilme(filme *models.CriarFilme) []string {
    var erros []string
    
    // Validar t√≠tulo
    if strings.TrimSpace(filme.Titulo) == "" {
        erros = append(erros, "t√≠tulo √© obrigat√≥rio")
    } else if len(filme.Titulo) > 255 {
        erros = append(erros, "t√≠tulo deve ter no m√°ximo 255 caracteres")
    }
```

**Padr√£o de Valida√ß√£o:**
1. **Slice de erros**: Coleta todos os problemas
2. **Valida√ß√£o por campo**: Uma valida√ß√£o por vez
3. **Mensagens claras**: Usu√°rio sabe exatamente o que corrigir
4. **strings.TrimSpace()**: Remove espa√ßos antes/depois

### Valida√ß√µes Implementadas

#### 1. T√≠tulo
```go
if strings.TrimSpace(filme.Titulo) == "" {
    erros = append(erros, "t√≠tulo √© obrigat√≥rio")
} else if len(filme.Titulo) > 255 {
    erros = append(erros, "t√≠tulo deve ter no m√°ximo 255 caracteres")
}
```

#### 2. Ano de Lan√ßamento
```go
anoAtual := time.Now().Year()
if filme.AnoLancamento < 1888 { // Primeiro filme da hist√≥ria
    erros = append(erros, "ano de lan√ßamento deve ser posterior a 1888")
} else if filme.AnoLancamento > anoAtual+5 { // M√°ximo 5 anos no futuro
    erros = append(erros, fmt.Sprintf("ano de lan√ßamento n√£o pode ser superior a %d", anoAtual+5))
}
```

**Por que 1888?**
- "Roundhay Garden Scene" (1888) √© considerado o primeiro filme
- Valida√ß√£o baseada em fatos hist√≥ricos

#### 3. Dura√ß√£o
```go
if filme.DuracaoMinutos < 1 {
    erros = append(erros, "dura√ß√£o deve ser maior que 0 minutos")
} else if filme.DuracaoMinutos > 600 { // 10 horas m√°ximo
    erros = append(erros, "dura√ß√£o n√£o pode exceder 600 minutos")
}
```

#### 4. Avalia√ß√£o
```go
if filme.Avaliacao < 0 || filme.Avaliacao > 10 {
    erros = append(erros, "avalia√ß√£o deve estar entre 0 e 10")
}
```

### Fun√ß√£o LimparDados

```go
func LimparDados(filme *models.CriarFilme) {
    filme.Titulo = strings.TrimSpace(filme.Titulo)
    filme.Descricao = strings.TrimSpace(filme.Descricao)
    filme.Genero = strings.TrimSpace(filme.Genero)
    filme.Diretor = strings.TrimSpace(filme.Diretor)
}
```

**Sanitiza√ß√£o de Dados:**
- Remove espa√ßos extras
- Padroniza entrada do usu√°rio
- Previne erros de valida√ß√£o por espa√ßos

---

## üóÑÔ∏è Opera√ß√µes de Banco Atualizadas

### Arquivo: `internal/database/conexao.go` (Adi√ß√£o)

### Fun√ß√£o CriarFilme

```go
func (bd *BancoDados) CriarFilme(filme *models.CriarFilme) (int, error) {
    query := `
        INSERT INTO filmes (titulo, descricao, ano_lancamento, duracao_minutos, genero, diretor, avaliacao)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id
    `
    
    var novoID int
    
    err := bd.conexao.QueryRow(
        query,
        filme.Titulo,
        filme.Descricao,
        filme.AnoLancamento,
        filme.DuracaoMinutos,
        filme.Genero,
        filme.Diretor,
        filme.Avaliacao,
    ).Scan(&novoID)
    
    if err != nil {
        return 0, fmt.Errorf("erro ao inserir filme: %v", err)
    }
    
    fmt.Printf("üíæ Filme inserido com ID: %d\n", novoID)
    return novoID, nil
}
```

**Componentes importantes:**

1. **INSERT com RETURNING**: PostgreSQL retorna o ID gerado
2. **Prepared Statement**: `$1, $2, ...` previne SQL injection
3. **QueryRow()**: Para comandos que retornam uma linha
4. **Scan()**: Captura o ID retornado
5. **Error Handling**: Contexto espec√≠fico no erro

**RETURNING clause:**
```sql
-- ‚úÖ PostgreSQL - retorna o ID criado
INSERT INTO filmes (...) VALUES (...) RETURNING id;

-- ‚ùå Alternativa menos elegante
INSERT INTO filmes (...) VALUES (...);
SELECT lastval(); -- Perigoso em ambiente concorrente
```

---

## üöÄ Main.go Simplificado e Organizado

### Arquivo: `cmd/server/main.go` (Novo)

```go
package main

import (
    "fmt"
    "log"
    "net/http"
    
    "api-filmes/internal/database"
    "api-filmes/internal/handlers"
)

func main() {
    fmt.Println("üé¨ Servidor da API de Filmes v2.0 iniciando...")
    
    // Conectar ao banco
    bancoDados, err := database.NovaConexao()
    if err != nil {
        log.Fatal("‚ùå Erro ao conectar com banco:", err)
    }
    
    defer func() {
        if err := bancoDados.Fechar(); err != nil {
            log.Printf("‚ö†Ô∏è Erro ao fechar conex√£o: %v", err)
        } else {
            fmt.Println("üîå Conex√£o com banco fechada")
        }
    }()
    
    // Criar handler de filmes
    filmeHandler := handlers.NovoFilmeHandler(bancoDados)
    
    // Configurar rotas com middleware
    http.HandleFunc("/", aplicarMiddleware(filmeHandler.PaginaInicial))
    http.HandleFunc("/filmes", aplicarMiddleware(filmeHandler.ManipularFilmes))
    http.HandleFunc("/filmes/", aplicarMiddleware(filmeHandler.ManipularFilmeIndividual))
    
    // Iniciar servidor
    porta := ":8080"
    fmt.Printf("üöÄ Servidor rodando em http://localhost%s\n", porta)
    
    if err := http.ListenAndServe(porta, nil); err != nil {
        log.Fatal("‚ùå Erro ao iniciar servidor:", err)
    }
}

// aplicarMiddleware combina todos os middlewares
func aplicarMiddleware(handler http.HandlerFunc) http.HandlerFunc {
    return handlers.RecuperacaoMiddleware(
        handlers.CORSMiddleware(
            handlers.LogMiddleware(handler),
        ),
    )
}
```

**Evolu√ß√£o do main.go:**

**‚úÖ Agora:**
- **Apenas inicializa√ß√£o**: Foco na configura√ß√£o
- **Dependency Injection**: Passa depend√™ncias para handlers
- **Middleware Chain**: Combina middlewares de forma elegante
- **Error Handling**: Tratamento adequado de erros de inicializa√ß√£o

**‚ùå Antes:**
- Misturava inicializa√ß√£o com l√≥gica de neg√≥cio
- Vari√°veis globais
- Handlers soltos
- Sem middleware

### Cadeia de Middleware

```go
return handlers.RecuperacaoMiddleware(
    handlers.CORSMiddleware(
        handlers.LogMiddleware(handler),
    ),
)
```

**Ordem de execu√ß√£o:**
```
Request ‚Üí Recuperacao ‚Üí CORS ‚Üí Log ‚Üí Handler ‚Üí Response
```

**Por que essa ordem?**
1. **Recuperacao**: Mais externo, captura qualquer panic
2. **CORS**: Headers precisam ser definidos cedo
3. **Log**: Registra ap√≥s CORS, antes da l√≥gica
4. **Handler**: L√≥gica de neg√≥cio por √∫ltimo

---

## üß™ Testes Abrangentes

### 1. Prepara√ß√£o do Ambiente

```bash
# Verificar se banco est√° funcionando
go run cmd/server/main.go
```

**Sa√≠da esperada:**
```
üé¨ Servidor da API de Filmes v2.0 iniciando...
üîå Conectando ao banco de dados...
üìç Host: localhost:5432 | Banco: api_filmes
‚úÖ Conex√£o com banco estabelecida com sucesso!
üöÄ Servidor rodando em http://localhost:8080
```

### 2. Teste POST - Filme V√°lido

#### Configura√ß√£o do Postman:
- **M√©todo**: POST
- **URL**: `http://localhost:8080/filmes`
- **Headers**: 
  - `Content-Type: application/json`

#### Body (raw JSON):
```json
{
    "titulo": "Parasita",
    "descricao": "Uma fam√≠lia pobre se infiltra na casa de uma fam√≠lia rica",
    "ano_lancamento": 2019,
    "duracao_minutos": 132,
    "genero": "Thriller",
    "diretor": "Bong Joon-ho",
    "avaliacao": 8.6
}
```

#### Resposta Esperada (Status 201):
```json
{
    "id": 4,
    "titulo": "Parasita",
    "descricao": "Uma fam√≠lia pobre se infiltra na casa de uma fam√≠lia rica",
    "ano_lancamento": 2019,
    "duracao_minutos": 132,
    "genero": "Thriller",
    "diretor": "Bong Joon-ho",
    "avaliacao": 8.6,
    "data_criacao": "2024-01-20T15:30:45Z",
    "data_atualizacao": "2024-01-20T15:30:45Z"
}
```

#### Logs no Console:
```
üåê POST /filmes - IP: 127.0.0.1:54321 - User-Agent: PostmanRuntime/7.32.2
‚ûï Criando novo filme...
üíæ Filme inserido com ID: 4
‚úÖ Filme criado: Parasita (ID: 4)
üìä POST /filmes - Status: 201 - Dura√ß√£o: 45ms
```

### 3. Teste POST - Dados Inv√°lidos

#### Body com M√∫ltiplos Erros:
```json
{
    "titulo": "",
    "descricao": "Descri√ß√£o v√°lida",
    "ano_lancamento": 1800,
    "duracao_minutos": -5,
    "genero": "",
    "diretor": "",
    "avaliacao": 15
}
```

#### Resposta Esperada (Status 400):
```json
{
    "erro": "Dados inv√°lidos",
    "codigo": 400,
    "detalhes": "t√≠tulo √© obrigat√≥rio; ano de lan√ßamento deve ser posterior a 1888; dura√ß√£o deve ser maior que 0 minutos; g√™nero √© obrigat√≥rio; diretor √© obrigat√≥rio; avalia√ß√£o deve estar entre 0 e 10"
}
```

### 4. Teste POST - Content-Type Incorreto

#### Headers:
- `Content-Type: text/plain`

#### Resposta Esperada (Status 400):
```json
{
    "erro": "Content-Type deve ser application/json",
    "codigo": 400
}
```

### 5. Teste POST - JSON Malformado

#### Body Inv√°lido:
```json
{
    "titulo": "Filme"
    "ano": 2024    // Falta v√≠rgula
}
```

#### Resposta Esperada (Status 400):
```json
{
    "erro": "JSON inv√°lido",
    "codigo": 400
}
```

### 6. Teste POST - Campos Extras

#### Body com Campo N√£o Reconhecido:
```json
{
    "titulo": "Filme Teste",
    "ano_lancamento": 2024,
    "duracao_minutos": 120,
    "genero": "A√ß√£o",
    "diretor": "Diretor Teste",
    "avaliacao": 8.0,
    "campo_extra": "valor n√£o permitido"
}
```

#### Resposta Esperada (Status 400):
```json
{
    "erro": "JSON inv√°lido",
    "codigo": 400
}
```

### 7. Teste GET - Verificar Filme Criado

#### Requisi√ß√£o:
- **M√©todo**: GET
- **URL**: `http://localhost:8080/filmes/4`

#### Resposta:
```json
{
    "id": 4,
    "titulo": "Parasita",
    // ... dados completos
}
```

### 8. Teste GET - Lista Atualizada

#### Requisi√ß√£o:
- **M√©todo**: GET
- **URL**: `http://localhost:8080/filmes`

#### Verificar:
- Total aumentou
- Novo filme aparece na lista
- Ordena√ß√£o mantida

---

## üéì Conceitos Aprendidos

### 1. Organiza√ß√£o de C√≥digo
- **Handlers em Structs**: Organiza√ß√£o por funcionalidade
- **Dependency Injection**: Passagem de depend√™ncias
- **Separation of Concerns**: Cada arquivo com responsabilidade espec√≠fica

### 2. Middleware Pattern
- **Chain of Responsibility**: Cada middleware tem uma responsabilidade
- **Cross-cutting Concerns**: Logs, CORS, Recovery aplicados a todas as rotas
- **Composi√ß√£o**: Combina√ß√£o de m√∫ltiplos middlewares

### 3. Request Processing
- **Content-Type Validation**: Garantir formato correto
- **JSON Decoding**: Convers√£o de JSON para struct
- **Data Validation**: Verifica√ß√£o de regras de neg√≥cio
- **Error Handling**: Diferentes tipos de erro com status codes apropriados

### 4. HTTP Status Codes
- **200 OK**: Opera√ß√£o bem-sucedida (GET)
- **201 Created**: Recurso criado com sucesso (POST)
- **400 Bad Request**: Dados inv√°lidos do cliente
- **409 Conflict**: Viola√ß√£o de restri√ß√£o (t√≠tulo duplicado)
- **500 Internal Server Error**: Erro no servidor

### 5. Validation Strategies
- **Multiple Validation**: Coletar todos os erros de uma vez
- **Business Rules**: Valida√ß√µes baseadas em regras de neg√≥cio
- **Data Sanitization**: Limpeza de dados antes da valida√ß√£o
- **Contextual Messages**: Mensagens espec√≠ficas para cada erro

---

## üèóÔ∏è Padr√µes de Arquitetura Implementados

### 1. Handler Pattern
```go
// ‚úÖ Organizado em struct
type FilmeHandler struct {
    bancoDados *database.BancoDados
}

func (fh *FilmeHandler) criarFilme(w http.ResponseWriter, r *http.Request) {
    // L√≥gica espec√≠fica
}

// ‚ùå Fun√ß√µes globais desordenadas
func criarFilme(w http.ResponseWriter, r *http.Request) {
    // usa vari√°vel global
}
```

### 2. Middleware Chain Pattern
```go
// Middleware como Higher-Order Function
func LogMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // L√≥gica antes
        next.ServeHTTP(w, r)
        // L√≥gica depois
    })
}

// Composi√ß√£o de middlewares
aplicarMiddleware(handler) // Recovery -> CORS -> Log -> Handler
```

### 3. Data Transfer Object (DTO) Pattern
```go
// Entrada espec√≠fica para cria√ß√£o
type CriarFilme struct {
    Titulo string `json:"titulo"`
    // Apenas campos necess√°rios para cria√ß√£o
}

// Entidade completa para resposta
type Filme struct {
    ID              int       `json:"id"`
    DataCriacao     time.Time `json:"data_criacao"`
    // Todos os campos incluindo auto-gerados
}
```

### 4. Repository Pattern (Impl√≠cito)
```go
// Interface impl√≠cita
type FilmeRepository interface {
    CriarFilme(*models.CriarFilme) (int, error)
    BuscarFilmePorID(int) (*models.Filme, error)
    // Opera√ß√µes de dados abstra√≠das
}

// Implementa√ß√£o concreta
type BancoDados struct {
    conexao *sql.DB
}
```

### 5. Error Wrapping Pattern
```go
// Adicionar contexto aos erros
if err != nil {
    return 0, fmt.Errorf("erro ao inserir filme: %v", err)
}

// Tratamento espec√≠fico por tipo
if strings.Contains(err.Error(), "duplicate") {
    enviarErro(w, "Filme j√° existe", http.StatusConflict)
}
```

---

## üîÑ Fluxo de Dados Detalhado

### Request ‚Üí Response Flow (POST /filmes)

```
1. Cliente (Postman/Frontend)
   ‚Üì POST /filmes + JSON body
   
2. Go HTTP Server
   ‚Üì http.ListenAndServe
   
3. Middleware Chain
   ‚Üì Recovery ‚Üí CORS ‚Üí Log
   
4. FilmeHandler.ManipularFilmes()
   ‚Üì switch r.Method = "POST"
   
5. FilmeHandler.criarFilme()
   ‚Üì Content-Type validation
   
6. JSON Decoding
   ‚Üì json.NewDecoder(r.Body).Decode()
   
7. Data Validation
   ‚Üì validators.ValidarCriarFilme()
   
8. Database Layer
   ‚Üì bancoDados.CriarFilme()
   
9. PostgreSQL
   ‚Üì INSERT ... RETURNING id
   
10. Response Construction
    ‚Üì Buscar filme completo + JSON encoding
    
11. HTTP Response
    ‚Üì Status 201 + headers + JSON body
    
12. Cliente recebe filme criado
```

### Error Flow Examples

```
Erro de Valida√ß√£o:
Client ‚Üí JSON inv√°lido ‚Üí Validation ‚Üí 400 Bad Request

Erro de Duplica√ß√£o:
Client ‚Üí T√≠tulo existe ‚Üí PostgreSQL constraint ‚Üí 409 Conflict

Erro de Servidor:
Client ‚Üí Dados v√°lidos ‚Üí Database down ‚Üí 500 Internal Server Error
```

---

## üõ°Ô∏è Aspectos de Seguran√ßa Avan√ßados

### 1. Input Validation
```go
// ‚úÖ Valida√ß√£o robusta
if strings.TrimSpace(filme.Titulo) == "" {
    erros = append(erros, "t√≠tulo √© obrigat√≥rio")
}

// ‚úÖ Sanitiza√ß√£o
filme.Titulo = strings.TrimSpace(filme.Titulo)

// ‚úÖ Limite de tamanho
if len(filme.Titulo) > 255 {
    erros = append(erros, "t√≠tulo muito longo")
}
```

### 2. JSON Security
```go
// ‚úÖ Rejeitar campos desconhecidos
decoder.DisallowUnknownFields()

// ‚úÖ Verificar Content-Type
if r.Header.Get("Content-Type") != "application/json" {
    return BadRequest
}

// ‚úÖ Limitar tamanho do body (implementar quando necess√°rio)
r.Body = http.MaxBytesReader(w, r.Body, 1048576) // 1MB
```

### 3. SQL Injection Prevention
```go
// ‚úÖ SEGURO - Prepared statements
query := "INSERT INTO filmes (titulo) VALUES ($1)"
db.QueryRow(query, filme.Titulo)

// ‚ùå VULNER√ÅVEL - String concatenation
// query := "INSERT INTO filmes (titulo) VALUES ('" + filme.Titulo + "')"
```

### 4. Error Information Disclosure
```go
// ‚úÖ SEGURO - Log detalhado interno, mensagem gen√©rica externa
fmt.Printf("‚ùå Erro espec√≠fico: %v\n", err)           // Log
enviarErro(w, "Erro interno", 500)                   // Cliente

// ‚ùå PERIGOSO - Vazar detalhes internos
// enviarErro(w, err.Error(), 500)  // Pode expor paths, senhas, etc.
```

### 5. CORS Configuration
```go
// üö® Desenvolvimento - permite tudo
w.Header().Set("Access-Control-Allow-Origin", "*")

// ‚úÖ Produ√ß√£o - espec√≠fico
// w.Header().Set("Access-Control-Allow-Origin", "https://meusite.com")
```

---

## üìä Monitoramento e Observabilidade

### Logs Estruturados
```go
// Request logs
fmt.Printf("üåê %s %s - IP: %s - User-Agent: %s\n",
    r.Method, r.URL.Path, obterIPReal(r), r.UserAgent())

// Operation logs  
fmt.Printf("‚ûï Criando novo filme...\n")
fmt.Printf("üíæ Filme inserido com ID: %d\n", novoID)

// Performance logs
fmt.Printf("üìä %s %s - Status: %d - Dura√ß√£o: %v\n",
    r.Method, r.URL.Path, status, duracao)

// Error logs
fmt.Printf("‚ùå Erro ao salvar filme: %v\n", err)
```

### M√©tricas B√°sicas
```go
// Timing
inicio := time.Now()
// ... opera√ß√£o ...
duracao := time.Since(inicio)

// Status tracking
wrapperResposta.statusCode // Capturado pelo middleware

// Request info
r.Method, r.URL.Path, r.UserAgent(), obterIPReal(r)
```

### Health Indicators
```go
// Database connectivity
if err := conexao.Ping(); err != nil {
    return nil, fmt.Errorf("erro ao conectar com banco: %v", err)
}

// Successful operations
fmt.Printf("‚úÖ Filme criado: %s (ID: %d)\n", titulo, id)
```

---

## üîß Troubleshooting Avan√ßado

### Problema: "JSON inv√°lido" mas JSON parece correto
```bash
# Verificar encoding
file -I arquivo.json

# Verificar caracteres especiais
hexdump -C arquivo.json | head

# Usar validator online
# https://jsonlint.com
```

### Problema: "Content-Type deve ser application/json"
```bash
# No Postman, verificar:
# 1. Headers tab ‚Üí Content-Type: application/json
# 2. Body tab ‚Üí raw ‚Üí JSON (n√£o Text)
# 3. N√£o ter trailing spaces

# Via curl:
curl -X POST http://localhost:8080/filmes \
  -H "Content-Type: application/json" \
  -d '{"titulo": "Teste"}'
```

### Problema: Middleware n√£o executa
```go
// ‚úÖ Verificar se aplicarMiddleware est√° sendo usado
http.HandleFunc("/filmes", aplicarMiddleware(handler.ManipularFilmes))

// ‚ùå Sem middleware
// http.HandleFunc("/filmes", handler.ManipularFilmes)

// ‚úÖ Verificar ordem dos middlewares
aplicarMiddleware(handler) // Recovery ‚Üí CORS ‚Üí Log ‚Üí Handler
```

### Problema: "Filme j√° existe" mas n√£o deveria
```sql
-- Verificar constraint de unicidade
\d filmes

-- Ver se existe index √∫nico no t√≠tulo
\di

-- Se n√£o houver, criar:
-- CREATE UNIQUE INDEX idx_filmes_titulo ON filmes(titulo);
```

### Problema: Status code sempre 200
```go
// ‚ùå WriteHeader depois de Write
w.Write([]byte("dados"))
w.WriteHeader(400)  // Muito tarde!

// ‚úÖ WriteHeader antes de Write
w.WriteHeader(400)
w.Write([]byte("dados"))

// ‚úÖ Ou usar helper
enviarJSON(w, dados, 400)  // Faz na ordem correta
```

---

## üìà Performance e Otimiza√ß√£o

### Database Operations
```go
// ‚úÖ Usar prepared statements (j√° implementado)
db.QueryRow("SELECT * FROM filmes WHERE id = $1", id)

// ‚úÖ Buscar apenas campos necess√°rios
SELECT id, titulo, diretor FROM filmes  // Para listagem
SELECT * FROM filmes WHERE id = $1      // Para detalhes

// üîÆ Para otimiza√ß√µes futuras:
// - Connection pooling configuration
// - Query caching
// - Database indexes
```

### JSON Processing
```go
// ‚úÖ Stream processing (j√° implementado)
json.NewDecoder(r.Body).Decode(&struct)  // N√£o carrega tudo na mem√≥ria

// ‚úÖ Struct tags otimizadas
type Filme struct {
    ID int `json:"id"`  // Simples e direto
}

// üîÆ Para otimiza√ß√µes futuras:
// - JSON streaming para listas grandes
// - Compression middleware
```

### Memory Management
```go
// ‚úÖ Resource cleanup (j√° implementado)
defer linhas.Close()
defer bancoDados.Fechar()

// ‚úÖ Response writer wrapper eficiente
type responseWriter struct {
    http.ResponseWriter
    statusCode int  // Apenas o necess√°rio
}
```

---

## üéØ Prepara√ß√£o para M√≥dulo 3-B

### O que j√° funciona perfeitamente:
- ‚úÖ Cria√ß√£o de filmes via POST
- ‚úÖ Valida√ß√£o robusta de dados
- ‚úÖ Middleware funcionando
- ‚úÖ Logs detalhados
- ‚úÖ Tratamento de erros contextual
- ‚úÖ Organiza√ß√£o clara do c√≥digo

### O que vamos adicionar no M√≥dulo 3-B:
- üîú **PUT /filmes/{id}** - Atualizar filme completo
- üîú **PATCH /filmes/{id}** - Atualizar campos espec√≠ficos
- üîú **DELETE /filmes/{id}** - Remover filme
- üîú **Valida√ß√µes espec√≠ficas** para atualiza√ß√£o
- üîú **Concorr√™ncia b√°sica** com timestamps
- üîú **Soft delete** vs hard delete

### Conceitos que aprenderemos:
- **HTTP PUT vs PATCH**: Diferen√ßas conceituais e pr√°ticas
- **Partial Updates**: Como atualizar apenas alguns campos
- **Optimistic Locking**: Preven√ß√£o de atualiza√ß√µes concorrentes
- **Audit Trail**: Rastreamento de mudan√ßas
- **Cascade Operations**: Opera√ß√µes relacionadas

---

## üöÄ Compara√ß√£o: M√≥dulo 2 vs M√≥dulo 3-A

### M√≥dulo 2 (Apenas Leitura):
```go
// Estrutura simples
func listarFilmes(w http.ResponseWriter, r *http.Request) {
    filmes, _ := banco.BuscarTodos()
    json.NewEncoder(w).Encode(filmes)
}

// Sem valida√ß√£o
// Sem middleware
// C√≥digo no main.go
```

### M√≥dulo 3-A (Leitura + Escrita):
```go
// Estrutura organizada
type FilmeHandler struct {
    bancoDados *database.BancoDados
}

func (fh *FilmeHandler) criarFilme(w http.ResponseWriter, r *http.Request) {
    // 1. Validar Content-Type
    // 2. Decodificar JSON
    // 3. Validar dados
    // 4. Salvar no banco
    // 5. Retornar resultado
}

// Com middleware completo
// Com valida√ß√£o robusta
// C√≥digo organizado em pacotes
```

**Evolu√ß√£o alcan√ßada:**
- üéØ **Arquitetura profissional** vs c√≥digo iniciante
- üõ°Ô∏è **Seguran√ßa robusta** vs b√°sica
- üìä **Observabilidade completa** vs logs m√≠nimos
- üîß **Manutenibilidade alta** vs c√≥digo monol√≠tico
- üöÄ **Escalabilidade preparada** vs estrutura simples

---

## üìö Refer√™ncias e Estudos Adicionais

### Documenta√ß√£o Oficial
- [HTTP Package](https://pkg.go.dev/net/http) - Servidor HTTP
- [JSON Package](https://pkg.go.dev/encoding/json) - Manipula√ß√£o JSON
- [Strings Package](https://pkg.go.dev/strings) - Manipula√ß√£o de strings
- [Time Package](https://pkg.go.dev/time) - Opera√ß√µes com tempo

### Padr√µes e Pr√°ticas
- [Effective Go](https://golang.org/doc/effective_go.html) - Boas pr√°ticas
- [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments) - Conven√ß√µes
- [REST API Guidelines](https://github.com/microsoft/api-guidelines) - Padr√µes REST

### Seguran√ßa
- [OWASP Go Secure Coding](https://github.com/OWASP/Go-SCP) - Seguran√ßa em Go
- [Input Validation](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html) - Valida√ß√£o

### Ferramentas de Desenvolvimento
- **Postman**: Teste de APIs
- **JSON Validator**: Valida√ß√£o de JSON online
- **DB Browser**: Visualiza√ß√£o de dados
- **Go Playground**: Teste de c√≥digo Go

---

## ‚úÖ Checklist Final do M√≥dulo 3-A

### Configura√ß√£o e Estrutura:
- [ ] Nova estrutura de pastas criada
- [ ] Handlers organizados em struct
- [ ] Middleware funcionando
- [ ] Validadores implementados

### Funcionalidade POST:
- [ ] POST /filmes cria filme com dados v√°lidos
- [ ] Retorna status 201 Created
- [ ] Valida Content-Type application/json
- [ ] Rejeita campos desconhecidos
- [ ] Valida todos os campos obrigat√≥rios
- [ ] Retorna erros de valida√ß√£o detalhados

### Logs e Monitoramento:
- [ ] Logs de requisi√ß√£o aparecem
- [ ] Logs de opera√ß√£o aparecem
- [ ] Logs de performance aparecem
- [ ] Logs de erro aparecem

### Testes Realizados:
- [ ] Filme v√°lido criado com sucesso
- [ ] Dados inv√°lidos rejeitados com 400
- [ ] Content-Type incorreto rejeitado
- [ ] JSON malformado rejeitado
- [ ] Campos extras rejeitados
- [ ] Filme aparece na listagem GET

### Compreens√£o:
- [ ] Entendo diferen√ßa entre GET e POST
- [ ] Sei como funciona middleware chain
- [ ] Compreendo valida√ß√£o de dados
- [ ] Reconhe√ßo padr√µes de arquitetura aplicados
- [ ] Entendo fluxo request ‚Üí response completo

---

**üéâ Parab√©ns! Voc√™ completou o M√≥dulo 3-A e agora tem uma API que n√£o apenas l√™ dados, mas tamb√©m cria novos registros de forma segura e organizada!**

**No M√≥dulo 3-B, vamos completar o CRUD implementando as opera√ß√µes de atualiza√ß√£o e exclus√£o, tornando nossa API totalmente funcional!**